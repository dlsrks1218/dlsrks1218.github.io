---
layout: post
title: "데이터 통신과 컴퓨터 네트워크"
subtitle: "2장 데이터 통신"
date: 2020-06-16 16:25:10 -0400
background: '/img/posts/03.jpg'
---

## 데이터 통신  

### 직렬과 병렬 전송(Serial and Parallel Transfer)  

* 병렬 전송  

  * 여러 전송라인틀 통해 여러 비트를 동시에 전송  

  * 병렬 전송은 두 장치들간의 거리가 짧은 경우에 일반적으로 사용  

  * 예) PC -> 프린터로 전송(컴퓨터와 주변장치 연결)  

  * 긴거리일 경우 장점이 상실됨(비용 문제)  

* 직렬전송  

  * 하나의 라인으로 모든 비트를 보냄  

  * 긴 거리일 경우 병렬전송에 비해 비용이 적게 들고 신뢰성 증가  

  * 하지만 비트를 하나씩 보내게 되므로 병렬전송보다 느림  

* 비동기식 전송  

  * 한 번에 한 문자씩 보내거나 받는 방식  

  * 문자는 7~8 비트로 구성되며, 문자의 앞에 시작 비트(start bit)를, 끝에는 정지 비트(stop bit)를 첨가해 보냄  

  * 송신측과 수신측 사이에 동기를 맞추기 위한 클럭 신호를 사용하지 않음  

  * 시작 비트는 수신측에 문자에 해당하는 비트가 따라올 것이라는 것을 알려줌  

  * 문자 비트들을 모두 수신했을 때 정지 비트가 뒤따름  

  * 키보드, 프린터와 같은 느린 장치들을 위해 사용되며 높은 오버헤드를 가짐  

* 동기식 전송  

  * 바이트 기반 전송(Byte-Oriented Transmission)  

    * 각 프레임을 바이트의 연속으로 간주하는 방식  

  * 비트 기반 전송(Bit-Oriented Transmission) - 현재 많이 씀  

    * 각 프레임을 비트의 연송으로 간주하는 방식  

    * 프레임의 시작과 끝을 알리기 위해 플래그라고 하는 특수한 비트 패턴("01111110")을 사용  

    * 예 : 인터넷의 이더넷, HDLC(High-level Data Link Control) 등  

* 비트 스터핑(Bit Stuffing)  

  * 비트 기반 전송에서의 문제점  

    * 데이터 필드에 임의 값이 포함될 수 있다. 즉, 플래그 패턴(01111110)이 데이터 필드에 존재하게 되면 수신측에서는 이 부분을 프레임의 마지막으로 인식  

  * 이러한 문제를 해결 가능한 비트 스터핑  

  * 비트 스터핑 방법  

    * 송신측 : 데이터 필드 내에 연속되는 5개의 1이 발견되면 다섯 번째의 1 뒤에 0을 추가 삽입  

    * 수신측 :  연속되는 5개의 1이 수신되고 다음 비트가 0이면, 수신측은 0을 비트 스터핑 된 것으로 간주하고 제거  

  * 프레임의 시작과 끝에 위치한 플래그는 비트 스터핑을 하지 않으므로 유일하게 연속되는 6개의 1이 포함  

* 단방향, 반이중, 전이중  

  * 단방향(Simplex)  

    * 한 방향으로만 신호 전송이 가능한 형태  

    * 예) 공항 모니터, 프린터, TV 방송  

  * 반이중(Half duplex)  

    * 양쪽 방향에서 보내고 받을 수 있지만 교대로 전송  

    * 예) 무전기  

  * 전이중(Full duplex)  

    * 양쪽 호스트가 동시에 데이터 전송 가능  

    * 예) 인터넷  

### 교환 기술  
  
* 특징  

  * N개의 통신 장비를 직접 연결한다고 할 때 N(N-1)/2개의 연결선이 필요  

  * 해결방안으로 각각의 장비들은 통신망에 연결  

  * 통신망을 효과적으로 운영하기 위해 교환 기술을 사용  

* 기술 종류  

  * 회선 교환(Circuit Switching)  

  * 메시지 교환(Message Switching)  

  * 패킷 교환(Packet Switching)  

* 회선 교환(Circuit Switiching)

  * 공중 전화 망에서 사용  

  * 데이터 전송 과정  

    * 회선 설정  

    * 데이터 전송  

    * 회선 해제  

  * 단점 : 회선을 설정부터 해제까지 채널의 대역폭을 독점  

  * 장점 : 대역폭 독점으로 인한 신뢰성 있는 데이터 전송, 일정한 데이터 전송률로 전송  

  * 특징  

    * 자원을 독점적으로 예약, 보장된 성능 제공  

    * 회선 설정(call setup) 시간이 필요  

    * 링크 및 스위칭 장비가 성능에 영향  

* 다중화(Multiplexing) 기술  

  * 다수의 송신 호스트가 보내는 데이터를 하나의 전송매체를 통해 동시에 전송하는 기술  

  * 전송매체가 갖고 있는 대역폭을 다수의 채널로 분할하여 각각의 호스트가 하나의 채널을 사용하도록 하는 기술  

  * N개의 호스트가 전송매체의 대역폭을 공유하는 의미를 내포  

  * 대표적인 다중화 기술  

    * TDM(Time Division Multiplexing)  

      * 전송매체의 대역폭을 타임 슬롯으로 분할  

      * 각 호스트는 할당된 타임 슬롯을 사용하는 방식  

    * FDM(Frequency Division Multiplexing)  

      * 전송매체의 대역폭을 주파수로 분할  

      * 각 호스트는 할당된 주파수를 사용하는 방식이며 아날로그 신호에서 사용  

* 메시지 교환(Message Switching)  

  * 회선 교환 - 전화, 메시지 교환 - 편지  

  * 메시지라는 논리적 단위로 전송  

  * 메시지의 헤더에 목적지의 주소 표시  

  * 송신 호스트와 수신 호스트간 미리 경로를 설정할 필요 없음  

  * 각 노드는 메시지를 전부 받을 때까지 저장한 후 경로상의 또 다른 노드로 전송(Store-and-Forward)  

  * 장점  

    * 한 메시지를 복사하여 여러 목적지로 보낼 수 있음  

    * 메시지의 우선 순위를 정해 필요한 메시지 먼저 보낼 수 있음  

    * 메시지를 단위로 오류 제어 가능  

  * 단점  

    * 메시지가 노드에 잠시 저장되므로 지연이 발생  

    * 실시간을 요하는 통신에는 사용 어려움  

* 패킷 교환(Packet Switching)  

  * 회선 교환과 메시지 교환의 장점을 취함  

  * 패킷이라는 단위로 데이터 전송  

  * 패킷 : 정해진 형식에 맞추어진 데이터 단위  

  * 패킷에 목적지 주소 및 패킷의 성격, 형식 등의 정보가 저장  

  * 보통 128 ~ 4096 바이트 크기  

  * 패킷 교환의 두가지 방식  

    * 가상 회선(Virtual Circuit) : 논리적인 회선이 생성된 후 패킷 교환  

    * 데이터그램(Datagram) : 독점된 물리적 회선을 통해 패킷 교환

* 가상 회선(Virtual Circuit)  

  * 과정 : 연결 설정 - 데이터 전송 - 연결 해제  

  * 특징  

    * 논리적인 가상 회선을 설정  

    * 패킷들은 설정된 논리적인 회선을 통해 전송  

    * 많은 데이터를 안정적으로 전송할 때 유리  

    * 하나의 물리적 회선을 여러 논리적인 회선으로 공유할 수 있는 경제성 가짐  

  * 예  

    * 각 패킷은 VCI(Virtual Circuit ID)를 포함  

    * 가상회선 설정시간에 경로가 결정  

    * 각 라우터는 라우팅 테이블(Routing table) 유지  

* 데이터그램(Datagram)  

  * 과정 : 데이터 전송(연결 설정 및 해제 과정이 없음)  

  * 특징  

    * 하나의 패킷이 독립적으로 전송  

    * 각 패킷이 각기 다른 경로를 가질 수 있어 보낸 순서와 다르게 도착할 수 있음  

    * 매 패킷마다 새로운 전송 통로를 배정하기 때문에 네트워크 내의 상황에 능동적으로 대처  

    * 적은 양의 데이터를 신속하게 보낼 때 유리  

  * 예  

    * 패킷 내의 목적지 주소가 다음 경로 결정  

    * 각 라우터는 라우팅 테이블 유지  

### 오류 검출과 교정기법

* 단순 패리티 검사(Parity Check)  

  * 패리티 비트를 프레임의 각 문자 끝에 추가  

  * 패리티 비트 값은 자신을 포함하여 1의 개수가 짝수이면 짝수 패리티(Even Parity), 홀수 이면 홀수 패리티(Odd Parity)  

  * 예 : 송신측이 아스키 코드 G(11100001)를 홀수 패리티를 사용해 전송한다면 11100011을 전송  

  * 한계 : 두 개 혹은 임의의 짝수 개의 비트가 바뀌면 오류 검출 불가  

* 2차원(Two-Dimensinal) 패리티 검사  

  * 단순 패리티 검사는 한계가 존재  

  * 2차원 패리티 검사는 문자의 비트를 2차원 배열 형태로 구성하여 각 행(Row) 과 열(Column)마다 패리티 비트를 계산  

  * 3비트의 오류까지 검출 가능  

  * 한계 : 행과 열 방향에서 모두 짝수 개의 오류가 발생하면 오류 검출 불가  

* 체크섬(Checksum)  

  * 송신측  

    * 데이터를 m 비트로 분리 - 세그먼트  

    * m 비트의 세그먼트들을 모두 더하고 난 후 1의 보수(Complement)를 수행한 값이 **체크섬**  

    * 더하기하는 과정에서 가장 왼쪽 비트(MSB, Most Significant Bit)에서 캐리(Carry)가 생기면 구해진 합에 더함  

    * 1의 보수 : 각 비트의 0 -> 1, 1 -> 0으로 바꾸는 것  

    * 캐리(Carry) : 최상위 비트(MSB)에서 그 위의 비트로 자리올림이 발생하는 것  

  * 수신측  

    * 송신측에서 받은 모든 m 비트의 세그먼트들과 함께 체크섬도 모두 더함  

    * 만약 어떤 오류가 패킷에 있지 않다면 모두 더한 값은 m 비트가 모두 1이 됨  

    * 비트중의 하나라도 0이면 패킷에 오류가 있음을 의미  

    * **비트가 모두 1이라면 오류 X**  

* 순환 중복 검사(CRC, Cyclic Redundancy Check)  

  * 오류 검출에 주로 사용되며 매우 강력하면서 쉽게 구현 가능  

  * 인터넷에서 사용  

  * 송신측에서 보내려는 데이터에 CRC 과정을 거쳐 FCS(Frame Check Sequence) 코드값을 만들고 추가하여 보냄  

  * CRC 동작 과정  

    * 송신측  

      * n비트 프레임을 (k+1) 비트 생성 다항식(Generator Polynomial)으로 나누어 k비트 FCS를 생성  

        * 나누기 연산 전에 프레임을 왼쪽으로 k비트 이동, k비트 FCS를 추가하기 위함  

        * 나누기 연산으로 생긴 k비트 나머지(Remainder) -> FCS  

      * 송신 호스트가 실제 전송할 데이터 -> 프레임과 FCS, 총 (n+k)비트  

    * 수신측  

      * 수신 호스트는 송신 호스트가 보낸 (n+k)비트 데이터 받음  

      * 수신한 (n+k)비트 데이터를 생성 다항식으로 나눔  

        * 나머지가 0이면 오류가 발생 X  

        * 나머지가 0이 아니면 오류 발생 O  

* 해밍 코드(오류 교정 코드)  

  * N비트의 데이터에 k개의 패리티 비트를 더하여 (n+k)비트의 코드워드(Codeword)를 생성  

  * 방법  

    * 1비트 오류 정정 또는 2비트 오류 검출  

    * N비트 데이터와 k개의 패리티 비트 사용한다고 할때 다음 수식이 성립되어야 함  

    '''
    2^k - 1 >= n + k
    '''  

    * 수신측은 syndrome을 계산, 신드롬이 표현하는 십진수가 오류발생 위치  

      * 신드롬의 모든 비트가 0이면 오류 X  
