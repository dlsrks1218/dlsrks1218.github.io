---
layout: post
title: "Kubernetes"
subtitle: "쿠버네티스 1일차"
date: 2020-07-22 20:10:11 -0400
background: '/img/posts/01.jpg'
---

## Kubernetes 서문  

현재 다양한 인프라 구축의 핵심 기술은 컨테이너이다  
OS, DB, Web Server 등 인프라 구축에 필요한 컨테이너 이미지 각각을 조합해 인프라 환경을 손쉽게 설정할 수 있다  
하지만 이런 컨테이너를 각각 수동으로 관리하려면 적지 않은 수고가 필요하다  
쿠버네티스는 위 수고를 덜기 위해 자동으로 컨테이너를 관리하는 여러 도구 중 사실상 표준으로 인정받는 플랫폼이다  

## 쿠버네티스 입문 책 구성  

1. 쿠버네티스 소개  
2. 쿠버네티스 설치  
3. 쿠버네티스로 컨테이너 실행하기  
4. 쿠버네티스 아키텍처  
5. 파드  
6. 컨트롤러  
7. 서비스  
8. 인그레스  
9. 레이블과 애너테이션  
10. 컨피그맵  
11. 시크릿  
12. 파드 스케줄링  
13. 인증과 권한 관리  
14. 데이터 저장  
15. 클러스터 네트워킹 구성  
16. 쿠버네티스 DNS  
17. 로깅과 모니터링  
18. 오토스케일링  
19. 사용자 정의 자원  
20. 쿠버네티스 기반으로 워드프레스 앱 실행하기  
21. 헬름  

## 1 쿠버네티스 소개  

쿠버네티스는 여러 컨테이너 오케스트레이션 시스템(Docker Swarm, CoreOS fleet, D2iQ DC/OS 등) 중 사실상 표준 플랫폼  

### 1.1 컨테이너  

기존 리눅스의 격리환경은 다음 두 가지로 구성된다

* cgroup : 프로세스별로 자원을 격리해서 사용  

* chroot : 특정 디렉토리로 권한을 제한  

여기에 디스크의 파일 변경 사항을 레이어 형태로 저장하는 파일 시스템을 합해 컨테이너라는 개념이 탄생하였다  

도커는 위 기능들을 모아 컨테이너를 손쉽게 사용할 수 있도록 하여 주목을 받았다  

* 컨테이너 : 호스트 OS위에 도커가 있고 바로 앱이 위치  

* 가상머신 : 하이퍼바이저 위에 가상머신 마다 게스트 OS가 잇고 그 위에 앱이 위치  

도커  

* 간단한 명령을 통해 컨테이너 이미지를 만들고 저장소(registry)에 저장하며 도커를 설치한 호스트에 해당 컨테이너 이미지를 다운로드하여 컨테이너를 실행할 수 있다  

* 화물 선박의 컨테이너처럼 규격화한 컨테이너를 만든 후 실행하려는 호스트에 옮겨 그대로 사용한다  

컨테이너 등장 전에는 호스트에도 개발 환경에 필요한 설정을 똑같이 해야 하여 장애 요소가 많이 발생하였으며, 이를 컨테이너와 컨테이너 오케스트레이션 시스템으로 해결하며 앱을 배포하고 관리하기 편해졌다  

### 1.2 컨테이너 오케스트레이션 시스템  

컨테이너를 이용하면 개발 환경과 운영 환경의 차이 때문에 일어나는 많은 장애를 막을 수 있다  

개발 환경에서 실행했던 컨테이너를 컨테이너 런타임(예: 도커)만 있다면 실제 서버 어디든 실행할 수 있기 때문이다  

하지만 컨테이너만으로 실제 상용 서비스를 운영하기엔 모자람이 있어 컨테이너 오케스트레이션 시스템으로 부족함을 채운다  

* 컨테이너 오케스트레이션 시스템으로 상용 서비스에 사용할 서버들을 클러스터로 구성하면 많은 컨테이너를 한번의 명령으로 자동 배포할 수 있다  

* 사용중인 클러스터 일부에 장애가 발생하면 오케스트레이션 시스템은 알아서 장애가 발생한 서버에 있는 컨테이너들을 정상 운영 중인 다른 서버로 옮겨 실행한다  

* 장애가 발생한 서버로 향하는 트래픽도 자동으로 중지시키고 새로 옮긴 컨테이너로 보낸다  

* 개발자는 상용 서비스의 안정성을 컨테이너 오케스트레이터에 맡겨 두고 장애가 발생한 서버를 고치면 된다  

### 1.3 쿠버네티스  

쿠버네티스 : 배의 조타수라는 그리스어에 유래  

구글이 리눅스 재단과 협업해 클라우드 네이티브 컴퓨팅 재단(Cloud Native Computing Foundation)을 만들고 기부하였다  

2017년 깃허브가 웹서비스와 API를 쿠버네티스로 옮겼으며, 2019년 국내에서는 카카오톡, 다음, 멜론, 카카오택시 등의 서비스가 쿠버네티스를 이용한다  

### 1.4 쿠버네티스의 특징  

쿠버네티스가 많은 인기를 얻은 이유 : 선언적 API, 손쉬운 접근성, 강력한 커뮤니티  

* **선언적 API(declarative API)**  

쿠버네티스의 가장 큰 설계 원칙 : API가 선언적(declarative) - 컨테이너가 어떤 상태이길 원하는지만 쿠버네티스에 설정하면 지속해서 컨테이너의 상태를 확인하며 설정한 상태가 아니라면 그것에 맞게 맞춘다는 개념  

선언적 특징 : 현재 상태 확인 <-> 설정한 상태와의 차이 확인 <-> 설정한 상태로 맞추기  

선언적 특징의 장점  

    * 원하는 상태만 쿠버네티스에 정의해 유지할 수 있으므로 관리 비용이 많이 줄어든다  

    * 클러스터가 동작 중이라면 항상 원하는 상태로 자동 복구한다  

    * 쿠버네티스에 사용하는 컴포넌트들의 구현 또한 단순하다  

    * 단일 장애점(Single Point Of Failure, SPOF)  

선언적 특징의 단점  

    * 앱 재시작 같은 단순한 작업은 쿠버네티스에서 할 수 없음  

    * 앱 재시작은 쿠버네티스 시스템 내부 동작으로 사용자가 제어할 수 없음  

    * 하지만 최근 kubectl 이 직접 애너테이션을 변경하면서 재시작 동작을 제어하는 방식으로 바뀜  

* 워크로드 분리  

워크로드 : 작업 부하, 시스템의 사용자 및 App들이 발생시키는 전체 처리 요구량  

쿠버네티스는 OS처럼 분산된 프로세스의 관리를 추상화하는 레이어가 되므로 시스템 운영에 관한 고민을 많이 밀어 주어 클라우드의 리눅스라고 칭함  

* 어디서나 실행 가능  

* 방대한 커뮤니티  
